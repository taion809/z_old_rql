<?php
namespace Rql\Generated\Term;

// @@protoc_insertion_point(namespace:Rql.Generated.Term.TermType)

/**
 * Generated by the protocol buffer compiler.  DO NOT EDIT!
 * source: q2.proto
 *
 */
class TermType extends \ProtocolBuffers\Enum
{
  // @@protoc_insertion_point(traits:Rql.Generated.Term.TermType)
  
  /**
   * A RQL datum, stored in `datum` below.
   */
  const DATUM = 1;
  const MAKE_ARRAY = 2;
  /**
   * Evaluate the terms in [optargs] and make an object
   */
  const MAKE_OBJ = 3;
  /**
   * Takes an integer representing a variable and returns the value stored
   * in that variable.  It's the responsibility of the client to translate
   * from their local representation of a variable to a unique _non-negative_
   * integer for that variable.  (We do it this way instead of letting
   * clients provide variable names as strings to discourage
   * variable-capturing client libraries, and because it's more efficient
   * on the wire.)
   */
  const PB_VAR = 10;
  /**
   * Takes some javascript code and executes it.
   */
  const JAVASCRIPT = 11;
  /**
   * STRING {timeout: !NUMBER} -> Function(*)
   */
  const UUID = 169;
  /**
   * Takes an HTTP URL and gets it.  If the get succeeds and
   *  returns valid JSON, it is converted into a DATUM
   */
  const HTTP = 153;
  /**
   * Takes a string and throws an error with that message.
   * Inside of a `default` block, you can omit the first
   * argument to rethrow whatever error you catch (this is most
   * useful as an argument to the `default` filter optarg).
   */
  const ERROR = 12;
  /**
   * Takes nothing and returns a reference to the implicit variable.
   */
  const IMPLICIT_VAR = 13;
  /**
   * * Data Operators
   * Returns a reference to a database.
   */
  const DB = 14;
  /**
   * Returns a reference to a table.
   */
  const TABLE = 15;
  /**
   * STRING, {use_outdated:BOOL, identifier_format:STRING} -> Table
   * Gets a single element from a table by its primary or a secondary key.
   */
  const GET = 16;
  /**
   * Table, STRING -> NULL            | Table, NUMBER -> NULL |
   */
  const GET_ALL = 78;
  /**
   * Simple DATUM Ops
   */
  const EQ = 17;
  const NE = 18;
  const LT = 19;
  const LE = 20;
  const GT = 21;
  const GE = 22;
  const NOT = 23;
  /**
   * ADD can either add two numbers or concatenate two arrays.
   */
  const ADD = 24;
  const SUB = 25;
  const MUL = 26;
  const DIV = 27;
  const MOD = 28;
  /**
   * DATUM Array Ops
   * Append a single element to the end of an array (like `snoc`).
   */
  const APPEND = 29;
  /**
   * Prepend a single element to the end of an array (like `cons`).
   */
  const PREPEND = 80;
  /**
   * Remove the elements of one array from another array.
   */
  const DIFFERENCE = 95;
  /**
   * DATUM Set Ops
   * Set ops work on arrays. They don't use actual sets and thus have
   * performance characteristics you would expect from arrays rather than
   * from sets. All set operations have the post condition that they
   * array they return contains no duplicate values.
   */
  const SET_INSERT = 88;
  const SET_INTERSECTION = 89;
  const SET_UNION = 90;
  const SET_DIFFERENCE = 91;
  const SLICE = 30;
  const SKIP = 70;
  const LIMIT = 71;
  const INDEXES_OF = 87;
  const CONTAINS = 93;
  /**
   * Stream/Object Ops
   * Get a particular field from an object, or map that over a
   * sequence.
   */
  const GET_FIELD = 31;
  /**
   * | Sequence, STRING -> Sequence
   * Return an array containing the keys of the object.
   */
  const KEYS = 94;
  /**
   * Creates an object
   */
  const OBJECT = 143;
  /**
   * Check whether an object contains all the specified fields,
   * or filters a sequence so that all objects inside of it
   * contain all the specified fields.
   */
  const HAS_FIELDS = 32;
  /**
   * x.with_fields(...) <=> x.has_fields(...).pluck(...)
   */
  const WITH_FIELDS = 96;
  /**
   * Get a subset of an object by selecting some attributes to preserve,
   * or map that over a sequence.  (Both pick and pluck, polymorphic.)
   */
  const PLUCK = 33;
  /**
   * Get a subset of an object by selecting some attributes to discard, or
   * map that over a sequence.  (Both unpick and without, polymorphic.)
   */
  const WITHOUT = 34;
  /**
   * Merge objects (right-preferential)
   */
  const MERGE = 35;
  /**
   * Sequence Ops
   * Get all elements of a sequence between two values.
   * Half-open by default, but the openness of either side can be
   * changed by passing 'closed' or 'open for `right_bound` or
   * `left_bound`.
   */
  const BETWEEN = 36;
  const REDUCE = 37;
  const MAP = 38;
  /**
   * Filter a sequence with either a function or a shortcut
   * object (see API docs for details).  The body of FILTER is
   * wrapped in an implicit `.default(false)`, and you can
   * change the default value by specifying the `default`
   * optarg.  If you make the default `r.error`, all errors
   * caught by `default` will be rethrown as if the `default`
   * did not exist.
   */
  const FILTER = 39;
  /**
   * Sequence, OBJECT, {default:DATUM} -> Sequence
   * Map a function over a sequence and then concatenate the results together.
   */
  const CONCAT_MAP = 40;
  /**
   * Order a sequence based on one or more attributes.
   */
  const ORDER_BY = 41;
  /**
   * Get all distinct elements of a sequence (like `uniq`).
   */
  const DISTINCT = 42;
  /**
   * Count the number of elements in a sequence, or only the elements that match
   * a given filter.
   */
  const COUNT = 43;
  const IS_EMPTY = 86;
  /**
   * Take the union of multiple sequences (preserves duplicate elements! (use distinct)).
   */
  const UNION = 44;
  /**
   * Get the Nth element of a sequence.
   */
  const NTH = 45;
  /**
   * do NTH or GET_FIELD depending on target object
   */
  const BRACKET = 170;
  const INNER_JOIN = 48;
  const OUTER_JOIN = 49;
  /**
   * An inner-join that does an equality comparison on two attributes.
   */
  const EQ_JOIN = 50;
  const ZIP = 72;
  const RANGE = 173;
  /**
   * Array Ops
   * Insert an element in to an array at a given index.
   */
  const INSERT_AT = 82;
  /**
   * Remove an element at a given index from an array.
   */
  const DELETE_AT = 83;
  /**
   * ARRAY, NUMBER, NUMBER -> ARRAY
   * Change the element at a given index of an array.
   */
  const CHANGE_AT = 84;
  /**
   * Splice one array in to another array.
   */
  const SPLICE_AT = 85;
  /**
   * * Type Ops
   * Coerces a datum to a named type (e.g. "bool").
   * If you previously used `stream_to_array`, you should use this instead
   * with the type "array".
   */
  const COERCE_TO = 51;
  /**
   * Returns the named type of a datum (e.g. TYPE_OF(true) = "BOOL")
   */
  const TYPE_OF = 52;
  /**
   * * Write Ops (the OBJECTs contain data about number of errors etc.)
   * Updates all the rows in a selection.  Calls its Function with the row
   * to be updated, and then merges the result of that call.
   */
  const UPDATE = 53;
  /**
   * SingleSelection, Function(1), {non_atomic:BOOL, durability:STRING, return_changes:BOOL} -> OBJECT |
   * StreamSelection, OBJECT,      {non_atomic:BOOL, durability:STRING, return_changes:BOOL} -> OBJECT |
   * SingleSelection, OBJECT,      {non_atomic:BOOL, durability:STRING, return_changes:BOOL} -> OBJECT
   * Deletes all the rows in a selection.
   */
  const DELETE = 54;
  /**
   * Replaces all the rows in a selection.  Calls its Function with the row
   * to be replaced, and then discards it and stores the result of that
   * call.
   */
  const REPLACE = 55;
  /**
   * Inserts into a table.  If `conflict` is replace, overwrites
   * entries with the same primary key.  If `conflict` is
   * update, does an update on the entry.  If `conflict` is
   * error, or is omitted, conflicts will trigger an error.
   */
  const INSERT = 56;
  /**
   * * Administrative OPs
   * Creates a database with a particular name.
   */
  const DB_CREATE = 57;
  /**
   * Drops a database with a particular name.
   */
  const DB_DROP = 58;
  /**
   * Lists all the databases by name.  (Takes no arguments)
   */
  const DB_LIST = 59;
  /**
   * With no arguments, returns the contents of the `rethinkdb.db_config` system
   * table. With string arguments, returns only the rows corresponding to the DBs
   * with the given names.
   */
  const DB_CONFIG = 178;
  /**
   * Creates a table with a particular name in a particular
   * database.  (You may omit the first argument to use the
   * default database.)
   */
  const TABLE_CREATE = 60;
  /**
   * Database, STRING, {primary_key:STRING, shards:NUMBER, replicas:OBJECT, primary_replica_tag:STRING} -> OBJECT
   * STRING, {primary_key:STRING, shards:NUMBER, replicas:NUMBER, primary_replica_tag:STRING} -> OBJECT
   * STRING, {primary_key:STRING, shards:NUMBER, replicas:OBJECT, primary_replica_tag:STRING} -> OBJECT
   * Drops a table with a particular name from a particular
   * database.  (You may omit the first argument to use the
   * default database.)
   */
  const TABLE_DROP = 61;
  /**
   * STRING -> OBJECT
   * Lists all the tables in a particular database.  (You may
   * omit the first argument to use the default database.)
   */
  const TABLE_LIST = 62;
  /**
   * -> ARRAY
   * With no string arguments, returns the rows in the `rethinkdb.table_config`
   * system table for tables in the given database, or the default database if none
   * is specified. With string arguments, returns only the rows corresponding to
   * the tables with the given names.
   */
  const TABLE_CONFIG = 174;
  /**
   * [String...] -> StreamSelection
   * Like TABLE_CONFIG, except it returns the row in
   * `table_status` instead of `table_config`.
   */
  const TABLE_STATUS = 175;
  /**
   * [String...] -> StreamSelection
   * Waits for table(s) to be fully ready for read/write operations
   */
  const TABLE_WAIT = 177;
  /**
   * [String...] -> StreamSelection
   * Generates a new config for the given table, or all tables in the given database
   * The `shards` and `replicas` arguments are required
   */
  const RECONFIGURE = 176;
  /**
   * Database, {shards:NUMBER, replicas:OBJECT[, primary_replica_tag:STRING, dry_run:BOOLEAN]} -> ARRAY
   * Table, {shards:NUMBER, replicas:NUMBER[, primary_replica_tag:STRING, dry_run:BOOLEAN]} -> OBJECT
   * Table, {shards:NUMBER, replicas:OBJECT[, primary_replica_tag:STRING, dry_run:BOOLEAN]} -> OBJECT
   * Balances the table's shards but leaves everything else the same. Can also be
   * applied to an entire database at once.
   */
  const REBALANCE = 179;
  /**
   * Ensures that previously issued soft-durability writes are complete and
   * written to disk.
   */
  const SYNC = 138;
  /**
   * * Secondary indexes OPs
   * Creates a new secondary index with a particular name and definition.
   */
  const INDEX_CREATE = 75;
  /**
   * Drops a secondary index with a particular name from the specified table.
   */
  const INDEX_DROP = 76;
  /**
   * Lists all secondary indexes on a particular table.
   */
  const INDEX_LIST = 77;
  /**
   * Gets information about whether or not a set of indexes are ready to
   * be accessed. Returns a list of objects that look like this:
   * {index:STRING, ready:BOOL[, blocks_processed:NUMBER, blocks_total:NUMBER]}
   */
  const INDEX_STATUS = 139;
  /**
   * Blocks until a set of indexes are ready to be accessed. Returns the
   * same values INDEX_STATUS.
   */
  const INDEX_WAIT = 140;
  /**
   * Renames the given index to a new name
   */
  const INDEX_RENAME = 156;
  /**
   * * Control Operators
   * Calls a function on data
   */
  const FUNCALL = 64;
  /**
   * Executes its first argument, and returns its second argument if it
   * got [true] or its third argument if it got [false] (like an `if`
   * statement).
   */
  const BRANCH = 65;
  /**
   * Returns true if any of its arguments returns true (short-circuits).
   * (Like `or` in most languages.)
   */
  const ANY = 66;
  /**
   * Returns true if all of its arguments return true (short-circuits).
   * (Like `and` in most languages.)
   */
  const ALL = 67;
  /**
   * Calls its Function with each entry in the sequence
   * and executes the array of terms that Function returns.
   */
  const FOR_EACH = 68;
  /**
   * An anonymous function.  Takes an array of numbers representing
   * variables (see [VAR] above), and a [Term] to execute with those in
   * scope.  Returns a function that may be passed an array of arguments,
   * then executes the Term with those bound to the variable names.  The
   * user will never construct this directly.  We use it internally for
   * things like `map` which take a function.  The "arity" of a [Function] is
   * the number of arguments it takes.
   * For example, here's what `_X_.map{|x| x+2}` turns into:
   * Term {
   *   type = MAP;
   *   args = [_X_,
   *           Term {
   *             type = Function;
   *             args = [Term {
   *                       type = DATUM;
   *                       datum = Datum {
   *                         type = R_ARRAY;
   *                         r_array = [Datum { type = R_NUM; r_num = 1; }];
   *                       };
   *                     },
   *                     Term {
   *                       type = ADD;
   *                       args = [Term {
   *                                 type = VAR;
   *                                 args = [Term {
   *                                           type = DATUM;
   *                                           datum = Datum { type = R_NUM;
   *                                                           r_num = 1};
   *                                         }];
   *                               },
   *                               Term {
   *                                 type = DATUM;
   *                                 datum = Datum { type = R_NUM; r_num = 2; };
   *                               }];
   *                     }];
   *           }];
   */
  const FUNC = 69;
  /**
   * Indicates to ORDER_BY that this attribute is to be sorted in ascending order.
   */
  const ASC = 73;
  /**
   * Indicates to ORDER_BY that this attribute is to be sorted in descending order.
   */
  const DESC = 74;
  /**
   * Gets info about anything.  INFO is most commonly called on tables.
   */
  const INFO = 79;
  /**
   * `a.match(b)` returns a match object if the string `a`
   * matches the regular expression `b`.
   */
  const MATCH = 97;
  /**
   * Change the case of a string.
   */
  const UPCASE = 141;
  const DOWNCASE = 142;
  /**
   * Select a number of elements from sequence with uniform distribution.
   */
  const SAMPLE = 81;
  /**
   * Evaluates its first argument.  If that argument returns
   * NULL or throws an error related to the absence of an
   * expected value (for instance, accessing a non-existent
   * field or adding NULL to an integer), DEFAULT will either
   * return its second argument or execute it if it's a
   * function.  If the second argument is a function, it will be
   * passed either the text of the error or NULL as its
   * argument.
   */
  const PB_DEFAULT = 92;
  /**
   * Parses its first argument as a json string and returns it as a
   * datum.
   */
  const JSON = 98;
  /**
   * Returns the datum as a JSON string.
   * N.B.: we would really prefer this be named TO_JSON and that exists as
   * an alias in Python and JavaScript drivers; however it conflicts with the
   * standard `to_json` method defined by Ruby's standard json library.
   */
  const TO_JSON_STRING = 172;
  /**
   * Parses its first arguments as an ISO 8601 time and returns it as a
   * datum.
   */
  const ISO8601 = 99;
  /**
   * Prints a time as an ISO 8601 time.
   */
  const TO_ISO8601 = 100;
  /**
   * Returns a time given seconds since epoch in UTC.
   */
  const EPOCH_TIME = 101;
  /**
   * Returns seconds since epoch in UTC given a time.
   */
  const TO_EPOCH_TIME = 102;
  /**
   * The time the query was received by the server.
   */
  const NOW = 103;
  /**
   * Puts a time into an ISO 8601 timezone.
   */
  const IN_TIMEZONE = 104;
  /**
   * a.during(b, c) returns whether a is in the range [b, c)
   */
  const DURING = 105;
  /**
   * Retrieves the date portion of a time.
   */
  const DATE = 106;
  /**
   * x.time_of_day == x.date - x
   */
  const TIME_OF_DAY = 126;
  /**
   * Returns the timezone of a time.
   */
  const TIMEZONE = 127;
  /**
   * These access the various components of a time.
   */
  const YEAR = 128;
  const MONTH = 129;
  const DAY = 130;
  const DAY_OF_WEEK = 131;
  const DAY_OF_YEAR = 132;
  const HOURS = 133;
  const MINUTES = 134;
  const SECONDS = 135;
  /**
   * Construct a time from a date and optional timezone or a
   * date+time and optional timezone.
   */
  const TIME = 136;
  /**
   * Constants for ISO 8601 days of the week.
   */
  const MONDAY = 107;
  const TUESDAY = 108;
  const WEDNESDAY = 109;
  const THURSDAY = 110;
  const FRIDAY = 111;
  const SATURDAY = 112;
  const SUNDAY = 113;
  /**
   * Constants for ISO 8601 months.
   */
  const JANUARY = 114;
  const FEBRUARY = 115;
  const MARCH = 116;
  const APRIL = 117;
  const MAY = 118;
  const JUNE = 119;
  const JULY = 120;
  const AUGUST = 121;
  const SEPTEMBER = 122;
  const OCTOBER = 123;
  const NOVEMBER = 124;
  const DECEMBER = 125;
  /**
   * Indicates to MERGE to replace the other object rather than merge it.
   */
  const LITERAL = 137;
  /**
   * SEQUENCE, STRING -> GROUPED_SEQUENCE | SEQUENCE, FUNCTION -> GROUPED_SEQUENCE
   */
  const GROUP = 144;
  const SUM = 145;
  const AVG = 146;
  const MIN = 147;
  const MAX = 148;
  /**
   * `str.split()` splits on whitespace
   * `str.split(" ")` splits on spaces only
   * `str.split(" ", 5)` splits on spaces with at most 5 results
   * `str.split(nil, 5)` splits on whitespace with at most 5 results
   */
  const SPLIT = 149;
  const UNGROUP = 150;
  /**
   * Takes a range of numbers and returns a random number within the range
   */
  const RANDOM = 151;
  const CHANGES = 152;
  const ARGS = 154;
  /**
   * BINARY is client-only at the moment, it is not supported on the server
   */
  const BINARY = 155;
  const GEOJSON = 157;
  const TO_GEOJSON = 158;
  const POINT = 159;
  const LINE = 160;
  const POLYGON = 161;
  const DISTANCE = 162;
  const INTERSECTS = 163;
  const INCLUDES = 164;
  const CIRCLE = 165;
  const GET_INTERSECTING = 166;
  const FILL = 167;
  const GET_NEAREST = 168;
  const POLYGON_SUB = 171;
  
  // @@protoc_insertion_point(const_scope:Rql.Generated.Term.TermType)
  
  // @@protoc_insertion_point(class_scope:Rql.Generated.Term.TermType)
  
  /**
   * @return \ProtocolBuffers\EnumDescriptor
   */
  public static function getEnumDescriptor()
  {
    static $descriptor;
    if (!$descriptor) {
      $builder = new \ProtocolBuffers\EnumDescriptorBuilder();
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::DATUM,
        "name"  => 'DATUM',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::MAKE_ARRAY,
        "name"  => 'MAKE_ARRAY',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::MAKE_OBJ,
        "name"  => 'MAKE_OBJ',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::PB_VAR,
        "name"  => 'VAR',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::JAVASCRIPT,
        "name"  => 'JAVASCRIPT',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::UUID,
        "name"  => 'UUID',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::HTTP,
        "name"  => 'HTTP',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::ERROR,
        "name"  => 'ERROR',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::IMPLICIT_VAR,
        "name"  => 'IMPLICIT_VAR',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::DB,
        "name"  => 'DB',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::TABLE,
        "name"  => 'TABLE',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::GET,
        "name"  => 'GET',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::GET_ALL,
        "name"  => 'GET_ALL',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::EQ,
        "name"  => 'EQ',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::NE,
        "name"  => 'NE',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::LT,
        "name"  => 'LT',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::LE,
        "name"  => 'LE',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::GT,
        "name"  => 'GT',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::GE,
        "name"  => 'GE',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::NOT,
        "name"  => 'NOT',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::ADD,
        "name"  => 'ADD',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::SUB,
        "name"  => 'SUB',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::MUL,
        "name"  => 'MUL',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::DIV,
        "name"  => 'DIV',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::MOD,
        "name"  => 'MOD',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::APPEND,
        "name"  => 'APPEND',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::PREPEND,
        "name"  => 'PREPEND',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::DIFFERENCE,
        "name"  => 'DIFFERENCE',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::SET_INSERT,
        "name"  => 'SET_INSERT',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::SET_INTERSECTION,
        "name"  => 'SET_INTERSECTION',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::SET_UNION,
        "name"  => 'SET_UNION',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::SET_DIFFERENCE,
        "name"  => 'SET_DIFFERENCE',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::SLICE,
        "name"  => 'SLICE',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::SKIP,
        "name"  => 'SKIP',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::LIMIT,
        "name"  => 'LIMIT',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::INDEXES_OF,
        "name"  => 'INDEXES_OF',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::CONTAINS,
        "name"  => 'CONTAINS',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::GET_FIELD,
        "name"  => 'GET_FIELD',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::KEYS,
        "name"  => 'KEYS',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::OBJECT,
        "name"  => 'OBJECT',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::HAS_FIELDS,
        "name"  => 'HAS_FIELDS',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::WITH_FIELDS,
        "name"  => 'WITH_FIELDS',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::PLUCK,
        "name"  => 'PLUCK',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::WITHOUT,
        "name"  => 'WITHOUT',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::MERGE,
        "name"  => 'MERGE',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::BETWEEN,
        "name"  => 'BETWEEN',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::REDUCE,
        "name"  => 'REDUCE',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::MAP,
        "name"  => 'MAP',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::FILTER,
        "name"  => 'FILTER',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::CONCAT_MAP,
        "name"  => 'CONCAT_MAP',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::ORDER_BY,
        "name"  => 'ORDER_BY',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::DISTINCT,
        "name"  => 'DISTINCT',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::COUNT,
        "name"  => 'COUNT',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::IS_EMPTY,
        "name"  => 'IS_EMPTY',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::UNION,
        "name"  => 'UNION',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::NTH,
        "name"  => 'NTH',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::BRACKET,
        "name"  => 'BRACKET',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::INNER_JOIN,
        "name"  => 'INNER_JOIN',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::OUTER_JOIN,
        "name"  => 'OUTER_JOIN',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::EQ_JOIN,
        "name"  => 'EQ_JOIN',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::ZIP,
        "name"  => 'ZIP',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::RANGE,
        "name"  => 'RANGE',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::INSERT_AT,
        "name"  => 'INSERT_AT',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::DELETE_AT,
        "name"  => 'DELETE_AT',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::CHANGE_AT,
        "name"  => 'CHANGE_AT',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::SPLICE_AT,
        "name"  => 'SPLICE_AT',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::COERCE_TO,
        "name"  => 'COERCE_TO',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::TYPE_OF,
        "name"  => 'TYPE_OF',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::UPDATE,
        "name"  => 'UPDATE',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::DELETE,
        "name"  => 'DELETE',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::REPLACE,
        "name"  => 'REPLACE',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::INSERT,
        "name"  => 'INSERT',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::DB_CREATE,
        "name"  => 'DB_CREATE',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::DB_DROP,
        "name"  => 'DB_DROP',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::DB_LIST,
        "name"  => 'DB_LIST',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::DB_CONFIG,
        "name"  => 'DB_CONFIG',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::TABLE_CREATE,
        "name"  => 'TABLE_CREATE',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::TABLE_DROP,
        "name"  => 'TABLE_DROP',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::TABLE_LIST,
        "name"  => 'TABLE_LIST',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::TABLE_CONFIG,
        "name"  => 'TABLE_CONFIG',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::TABLE_STATUS,
        "name"  => 'TABLE_STATUS',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::TABLE_WAIT,
        "name"  => 'TABLE_WAIT',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::RECONFIGURE,
        "name"  => 'RECONFIGURE',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::REBALANCE,
        "name"  => 'REBALANCE',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::SYNC,
        "name"  => 'SYNC',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::INDEX_CREATE,
        "name"  => 'INDEX_CREATE',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::INDEX_DROP,
        "name"  => 'INDEX_DROP',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::INDEX_LIST,
        "name"  => 'INDEX_LIST',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::INDEX_STATUS,
        "name"  => 'INDEX_STATUS',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::INDEX_WAIT,
        "name"  => 'INDEX_WAIT',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::INDEX_RENAME,
        "name"  => 'INDEX_RENAME',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::FUNCALL,
        "name"  => 'FUNCALL',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::BRANCH,
        "name"  => 'BRANCH',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::ANY,
        "name"  => 'ANY',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::ALL,
        "name"  => 'ALL',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::FOR_EACH,
        "name"  => 'FOR_EACH',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::FUNC,
        "name"  => 'FUNC',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::ASC,
        "name"  => 'ASC',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::DESC,
        "name"  => 'DESC',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::INFO,
        "name"  => 'INFO',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::MATCH,
        "name"  => 'MATCH',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::UPCASE,
        "name"  => 'UPCASE',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::DOWNCASE,
        "name"  => 'DOWNCASE',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::SAMPLE,
        "name"  => 'SAMPLE',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::PB_DEFAULT,
        "name"  => 'DEFAULT',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::JSON,
        "name"  => 'JSON',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::TO_JSON_STRING,
        "name"  => 'TO_JSON_STRING',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::ISO8601,
        "name"  => 'ISO8601',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::TO_ISO8601,
        "name"  => 'TO_ISO8601',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::EPOCH_TIME,
        "name"  => 'EPOCH_TIME',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::TO_EPOCH_TIME,
        "name"  => 'TO_EPOCH_TIME',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::NOW,
        "name"  => 'NOW',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::IN_TIMEZONE,
        "name"  => 'IN_TIMEZONE',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::DURING,
        "name"  => 'DURING',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::DATE,
        "name"  => 'DATE',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::TIME_OF_DAY,
        "name"  => 'TIME_OF_DAY',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::TIMEZONE,
        "name"  => 'TIMEZONE',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::YEAR,
        "name"  => 'YEAR',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::MONTH,
        "name"  => 'MONTH',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::DAY,
        "name"  => 'DAY',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::DAY_OF_WEEK,
        "name"  => 'DAY_OF_WEEK',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::DAY_OF_YEAR,
        "name"  => 'DAY_OF_YEAR',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::HOURS,
        "name"  => 'HOURS',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::MINUTES,
        "name"  => 'MINUTES',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::SECONDS,
        "name"  => 'SECONDS',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::TIME,
        "name"  => 'TIME',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::MONDAY,
        "name"  => 'MONDAY',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::TUESDAY,
        "name"  => 'TUESDAY',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::WEDNESDAY,
        "name"  => 'WEDNESDAY',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::THURSDAY,
        "name"  => 'THURSDAY',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::FRIDAY,
        "name"  => 'FRIDAY',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::SATURDAY,
        "name"  => 'SATURDAY',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::SUNDAY,
        "name"  => 'SUNDAY',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::JANUARY,
        "name"  => 'JANUARY',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::FEBRUARY,
        "name"  => 'FEBRUARY',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::MARCH,
        "name"  => 'MARCH',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::APRIL,
        "name"  => 'APRIL',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::MAY,
        "name"  => 'MAY',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::JUNE,
        "name"  => 'JUNE',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::JULY,
        "name"  => 'JULY',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::AUGUST,
        "name"  => 'AUGUST',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::SEPTEMBER,
        "name"  => 'SEPTEMBER',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::OCTOBER,
        "name"  => 'OCTOBER',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::NOVEMBER,
        "name"  => 'NOVEMBER',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::DECEMBER,
        "name"  => 'DECEMBER',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::LITERAL,
        "name"  => 'LITERAL',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::GROUP,
        "name"  => 'GROUP',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::SUM,
        "name"  => 'SUM',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::AVG,
        "name"  => 'AVG',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::MIN,
        "name"  => 'MIN',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::MAX,
        "name"  => 'MAX',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::SPLIT,
        "name"  => 'SPLIT',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::UNGROUP,
        "name"  => 'UNGROUP',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::RANDOM,
        "name"  => 'RANDOM',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::CHANGES,
        "name"  => 'CHANGES',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::ARGS,
        "name"  => 'ARGS',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::BINARY,
        "name"  => 'BINARY',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::GEOJSON,
        "name"  => 'GEOJSON',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::TO_GEOJSON,
        "name"  => 'TO_GEOJSON',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::POINT,
        "name"  => 'POINT',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::LINE,
        "name"  => 'LINE',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::POLYGON,
        "name"  => 'POLYGON',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::DISTANCE,
        "name"  => 'DISTANCE',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::INTERSECTS,
        "name"  => 'INTERSECTS',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::INCLUDES,
        "name"  => 'INCLUDES',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::CIRCLE,
        "name"  => 'CIRCLE',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::GET_INTERSECTING,
        "name"  => 'GET_INTERSECTING',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::FILL,
        "name"  => 'FILL',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::GET_NEAREST,
        "name"  => 'GET_NEAREST',
      )));
      $builder->addValue(new \ProtocolBuffers\EnumValueDescriptor(array(
        "value" => self::POLYGON_SUB,
        "name"  => 'POLYGON_SUB',
      )));
      // @@protoc_insertion_point(builder_scope:Rql.Generated.Term.TermType)
      $descriptor = $builder->build();
    }
    return $descriptor;
  }
}
